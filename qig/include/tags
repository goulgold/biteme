!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD	instr.h	14;"	d
ADDI	instr.h	16;"	d
ADD_D	instr.h	15;"	d
ALU_	util.h	/^struct ALU_ {$/;"	s
ALU_ADDD	util.h	27;"	d
ALU_ADDI	util.h	24;"	d
ALU_DIVD	util.h	29;"	d
ALU_DIVI	util.h	26;"	d
ALU_MULD	util.h	28;"	d
ALU_MULI	util.h	25;"	d
ALU_line	util.h	/^struct ALU_line {$/;"	s
ARF_SIZE	util.h	8;"	d
BEQ	instr.h	31;"	d
BNE	instr.h	32;"	d
COMMIT	util.h	20;"	d
DIV	instr.h	24;"	d
DIV_D	instr.h	25;"	d
EXEC	util.h	18;"	d
FALSE	util.h	12;"	d
FREE	util.h	16;"	d
INSTR_H_	instr.h	2;"	d
ISSUE	util.h	17;"	d
L	instr.h	39;"	d
LD	instr.h	38;"	d
LOAD_STORE	util.h	30;"	d
MAX_ALU	util.h	9;"	d
MAX_DISPLAY	util.h	10;"	d
MAX_TTABLE_LINE	timingtable.h	4;"	d
MEM_SIZE	util.h	7;"	d
MULT	instr.h	22;"	d
MULT_D	instr.h	23;"	d
PARSER_H_	parser.h	2;"	d
PARSER_H_	template.h	2;"	d
RAT_line	util.h	/^struct RAT_line {$/;"	s
ROB_	util.h	/^struct ROB_ {$/;"	s
ROB_line	util.h	/^struct ROB_line {$/;"	s
RS_	util.h	/^struct RS_ {$/;"	s
RS_line	util.h	/^struct RS_line {$/;"	s
S	instr.h	41;"	d
SD	instr.h	40;"	d
SUB	instr.h	18;"	d
SUBI	instr.h	20;"	d
SUB_D	instr.h	19;"	d
TIMETABLE_H_	timingtable.h	2;"	d
TRUE	util.h	13;"	d
UPPER_H_	upper.h	2;"	d
UTIL_H_	util.h	2;"	d
WBACK	util.h	19;"	d
alu_index	util.h	/^    int alu_index; \/\/ use which alu to exec$/;"	m	struct:RS_line
alu_type	util.h	/^    int alu_type; \/\/ same as ALU_line$/;"	m	struct:RS_line
busy	util.h	/^    int busy; \/\/ occupied or not$/;"	m	struct:ROB_line
busy	util.h	/^    int busy; \/\/ this ALU is busy or not$/;"	m	struct:ALU_line
busy	util.h	/^    int busy;$/;"	m	struct:RS_line
commit	timingtable.h	/^    int commit; \/\/ cycle start commit$/;"	m	struct:timetable_line
cycles	util.h	/^    int cycles; \/\/ start cycles of this stage;$/;"	m	struct:RS_line
dst	util.h	/^    int dst; \/\/ index of ARF (start from 1)$/;"	m	struct:ROB_line
dst	util.h	/^    struct ROB_line *dst; \/\/destination$/;"	m	struct:RS_line	typeref:struct:RS_line::ROB_line
entity	util.h	/^    struct ALU_line *entity;$/;"	m	struct:ALU_	typeref:struct:ALU_::ALU_line
entity	util.h	/^    struct ROB_line *entity;$/;"	m	struct:ROB_	typeref:struct:ROB_::ROB_line
entity	util.h	/^    struct RS_line *entity;$/;"	m	struct:RS_	typeref:struct:RS_::RS_line
exec	timingtable.h	/^    int exec; \/\/ cycle start exec$/;"	m	struct:timetable_line
exec_cycle	util.h	/^    int exec_cycle; \/\/ how much cycles exec takes$/;"	m	struct:ALU_line
finished	util.h	/^    int finished; \/\/ finished or not$/;"	m	struct:ROB_line
index	timingtable.h	/^    int index; \/\/ index # in table$/;"	m	struct:timetable_line
index	util.h	/^    int index; \/\/ index of ROB (start from 1)$/;"	m	struct:ROB_line
input_instr	util.h	/^struct input_instr {$/;"	s
instr_addr	util.h	/^    int instr_addr; \/\/ which instr is loaded.$/;"	m	struct:RS_line
instr_type	util.h	/^    int instr_type; \/\/ same as instr.h$/;"	m	struct:RS_line
issue	timingtable.h	/^    int issue; \/\/ cycle start issue$/;"	m	struct:timetable_line
mem	timingtable.h	/^    int mem; \/\/ cycle start mem$/;"	m	struct:timetable_line
mem_addr	util.h	/^    int mem_addr; \/\/for load\/store instr$/;"	m	struct:RS_line
mem_cycle	util.h	/^    int mem_cycle; \/\/ how much cycles mem takes$/;"	m	struct:ALU_line
nextcommit	util.h	/^    int nextcommit;$/;"	m	struct:ROB_
nextfree	util.h	/^    int nextfree;$/;"	m	struct:ROB_
op	util.h	/^    int op; \/\/ instruction name. more details in instr.h$/;"	m	struct:input_instr
rd	util.h	/^    int rd; \/\/ destination register$/;"	m	struct:input_instr
re_name	util.h	/^    struct ROB_line *re_name; \/\/ reference to ROB if tag = 2$/;"	m	struct:RAT_line	typeref:struct:RAT_line::ROB_line
rs	util.h	/^    int rs; \/\/ source register$/;"	m	struct:input_instr
rt	util.h	/^    int rt; \/\/ target register or immediate$/;"	m	struct:input_instr
size	util.h	/^    int size;$/;"	m	struct:ALU_
size	util.h	/^    int size;$/;"	m	struct:ROB_
size	util.h	/^    int size;$/;"	m	struct:RS_
stage	util.h	/^    int stage; \/\/ 1:issue 2: exec; 3: write; 4:commit$/;"	m	struct:RS_line
tag	util.h	/^    int tag; \/\/ 0: register file; 1: ROB$/;"	m	struct:RAT_line
tag_1	util.h	/^    struct ROB_line *tag_1; \/\/ source$/;"	m	struct:RS_line	typeref:struct:RS_line::ROB_line
tag_2	util.h	/^    struct ROB_line *tag_2; \/\/target$/;"	m	struct:RS_line	typeref:struct:RS_line::ROB_line
timetable_line	timingtable.h	/^struct timetable_line {$/;"	s
ttable_index	util.h	/^    int ttable_index; \/\/ timing table index$/;"	m	struct:ROB_line
ttable_index	util.h	/^    int ttable_index; \/\/ timing table index$/;"	m	struct:RS_line
type	util.h	/^    int type; \/\/ which type ALU it is 1: int add\/sub; 2:int mul; 3:int div$/;"	m	struct:ALU_line
val	util.h	/^    float val; \/\/ value of result$/;"	m	struct:ROB_line
val_1	util.h	/^    float val_1; \/\/ source$/;"	m	struct:RS_line
val_2	util.h	/^    float val_2; \/\/ target$/;"	m	struct:RS_line
valid	util.h	/^    int valid; \/\/ because instuction buffer is constructed by this struct, thus$/;"	m	struct:input_instr
wb	timingtable.h	/^    int wb; \/\/ cycle start write back$/;"	m	struct:timetable_line
